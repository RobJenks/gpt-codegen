package org.rj.modelgen.bpmn.models.generation.multilevel.states;

import org.rj.modelgen.bpmn.component.BpmnComponentLibrary;
import org.rj.modelgen.bpmn.intrep.model.BpmnIntermediateModel;
import org.rj.modelgen.bpmn.intrep.model.ElementNode;
import org.rj.modelgen.bpmn.models.generation.multilevel.BpmnMultiLevelGenerationModel;
import org.rj.modelgen.bpmn.models.generation.validation.utils.ValidationUtils;
import org.rj.modelgen.llm.models.generation.multilevel.data.MultiLevelModelStandardPayloadData;
import org.rj.modelgen.llm.statemodel.states.common.ExecuteLogic;
import org.rj.modelgen.llm.util.Result;
import org.rj.modelgen.llm.util.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class PrepareBpmnModelForRendering extends ExecuteLogic {

    private static final Logger LOG = LoggerFactory.getLogger(PrepareBpmnModelForRendering.class);
    private String inputKeyOverride;

    public PrepareBpmnModelForRendering() {
        this(PrepareBpmnModelForRendering.class);
    }

    public PrepareBpmnModelForRendering(Class<? extends ExecuteLogic> cls) {
        super(cls);
    }

    public PrepareBpmnModelForRendering withInputKeyOverride(String inputKeyOverride) {
        this.inputKeyOverride = inputKeyOverride;
        return this;
    }

    @Override
    protected Mono<Result<Void, String>> executeLogic() {
        final var findModel = getModelData();
        if (findModel.isErr()) return Mono.just(Result.Err(findModel.getError()));
        final var model = findModel.getValue();

        final var componentLibrary = getComponentLibrary();
        if (componentLibrary == null) return Mono.just(Result.Err("Cannot prepare model for rendering; no component library available"));

        // Operations to be applied in order
        final List<Runnable> operations = List.of(
                () -> removeInvalidNullNodes(model),
                () -> eliminateDuplicateConnections(model),
                () -> eliminateDisallowedConnections(model, componentLibrary),
                () -> removeAutoGeneratedOutputsIfProvidedByModel(model, componentLibrary),
                () -> identifyOrphanedSubgraphs(model)
        );

        // Apply all operations; catch and propagate any unhandled exceptions
        for (final var operation : operations) {
            try {
                operation.run();
            } catch (Throwable t) {
                final var errorMessage = String.format("Error during model preparation operation: %s", t.getMessage());
                LOG.error(errorMessage, t);
                return Mono.just(Result.Err(errorMessage));
            }
        }

        // Save the modified model back to the payload
        final var saveResult = saveModelData(model);
        if (saveResult.isErr()) {
            return Mono.just(Result.Err("Failed to save model during render preparation: " + saveResult.getError()));
        }

        return Mono.just(Result.Ok());
    }

    // Remove any `null` nodes from the model.  Shouldn't happen but cleans up the model for future steps
    private void removeInvalidNullNodes(BpmnIntermediateModel model) {
        final var sanitized = model.getNodes().stream()
                .filter(Objects::nonNull)
                .toList();

        if (sanitized.size() != model.getNodes().size()) {
            LOG.info("Removing {} invalid null nodes from model", model.getNodes().size() - sanitized.size());
            model.setNodes(sanitized);
        }
    }

    // Identify any cases where a node is connected to another node via multiple edges, and remove the duplicate edges
    private void eliminateDuplicateConnections(BpmnIntermediateModel model) {
        for (final var node : model.getNodes()) {

            final var connections = node.getConnectedTo();
            // Make sure there are no duplicate connections within a group
            final var distinctConnections = connections.stream().distinct().toList();
            if (distinctConnections.size() != connections.size()) {
                node.setConnectedTo(distinctConnections);
            }
        }
    }

    // Remove any connections which are not permitted for the given action type.  E.g. if an action allows success outputs only, but the
    // model has generated an output failure connection, remove that connection to prevent malformed model output.  This is already
    // specified through the DL prompts so is a programmatic fallback in case this is not observed in all cases
    private void eliminateDisallowedConnections(BpmnIntermediateModel model, BpmnComponentLibrary componentLibrary) {
        //TODO: ? can there be any disallowed connections in BPMNs?
    }

    // Remove any outputs provided by the model which are actually the fixed / automatically-generated action outputs
    // These are generated automatically when the action runs and the HRS model does not need to provide values for them
    private void removeAutoGeneratedOutputsIfProvidedByModel(BpmnIntermediateModel model, BpmnComponentLibrary componentLibrary) {
        //TODO: ? can there be any auto-generated outputs in BPMNs?
    }

    // Identify orphaned subgraphs (which may more likely be individual nodes that became disconnected during preparation operations
    // above).  Remove them if they fall below a low threshold size.  Trigger a fatal generation error if they exceed the threshold
    // since it likely means we have generated a partitioned model and it needs to be fully regenerated
    private void identifyOrphanedSubgraphs(BpmnIntermediateModel model) {
        final int SUBGRAPH_SIZE_THRESHOLD = 3; // Threshold for pruning small subgraphs

        List<String> roots = ValidationUtils.identifyNumberOfRoots(model);

        // A correctly-formed model should have only one root (with |referrers| == 0)
        if (roots.size() == 1) {
            LOG.info("Validated that model is correctly-formed with a single root node ({})", roots.get(0));
            return;
        }

        // Model has no roots - it is cyclic and therefore invalid
        if (roots.isEmpty()) {
            final var error = "Generated model is cyclic with no roots; cannot continue with rendering";
            LOG.error(error);
            throw new RuntimeException(error);
        }

        // Model has multiple roots.  Determine the size of each subgraph.  If all bar one subgraph is below the threshold we
        // can prune them since they are minor orphaned nodes.  However if any are larger we either have a partitioned model or
        // multiple roots into the same large model
        final Map<String, List<String>> subgraphs = roots.stream()
                .collect(Collectors.toMap(Function.identity(), root -> calculateSubgraph(model, root)));

        final var aboveThreshold = subgraphs.entrySet().stream()
                .filter(e -> e.getValue().size() > SUBGRAPH_SIZE_THRESHOLD)
                .toList();

        // Fail if there are multiple subgraphs above the threshold (or if the model itself is small enough to be within the threshold)
        if (aboveThreshold.size() > 1 || model.getNodes().size() <= SUBGRAPH_SIZE_THRESHOLD) {
            final var error = String.format("Model contains multiple subgraphs.  More than one subgraph is above threshold size and so we cannot prune them " +
                            "to continue with rendering.  Model regeneration is required. Subgraph roots and sizes: [%s]",
                    subgraphs.entrySet().stream().map(e -> String.format("%s (%d)", e.getKey(), e.getValue().size())).collect(Collectors.joining(", ")));
            LOG.error(error);
            throw new RuntimeException(error);
        }

        // Multiple subgraphs, but all bar the main graph are below threshold so we can prune them.  There are no references to the subgraphs
        // from outside the subgraphs (by definition) so we can safely remove them
        LOG.warn("Model contains multiple subgraphs.  Extra subgraphs are below threshold size and will be removed to allow rendering. " +
                "Subgraph roots and sizes: [{}]", subgraphs.entrySet().stream().map(e -> String.format("%s (%d)", e.getKey(), e.getValue().size()))
                .collect(Collectors.joining(", ")));

        final var toRemove = subgraphs.entrySet().stream()
                .filter(e -> e.getValue().size() <= SUBGRAPH_SIZE_THRESHOLD)
                .toList();
        if (toRemove.size() != subgraphs.size() - 1) {
            LOG.warn("Expected to remove {} subgraphs but found {} to remove; skipping pruning logic", subgraphs.size() - 1, toRemove.size());
            return;
        }

        for (final var remove : toRemove) {
            LOG.info("Removing orphaned subgraph from model [{}]", String.join(", ", remove.getValue()));
            removeSubgraph(model, remove.getValue());
        }
    }

    private String getModelKey() {
        return Optional.ofNullable(inputKeyOverride).orElse(MultiLevelModelStandardPayloadData.DetailLevelModel.toString());
    }

    private BpmnComponentLibrary getComponentLibrary() {
        return Optional.ofNullable(getModel())
                .map(m -> m.getAs(BpmnMultiLevelGenerationModel.class))
                .map(BpmnMultiLevelGenerationModel::getComponentLibrary)
                .orElse(null);
    }

    private List<String> calculateSubgraph(BpmnIntermediateModel model, String root) {
        final Set<String> visited = new HashSet<>();
        final List<String> queue = new ArrayList<>();
        queue.add(root);

        Map<String, ElementNode> nodeMap = model.getNodes().stream()    // Lookup efficiency
                .collect(Collectors.toMap(ElementNode::getName, Function.identity()));

        while (!queue.isEmpty()) {
            final String nodeName = queue.remove(queue.size() - 1);
            if (visited.contains(nodeName)) continue;

            visited.add(nodeName);

            final var node = nodeMap.get(nodeName);
            if (node == null) {
                LOG.warn("Encountered unknown node name '{}' specified as target while calculating subgraph size; skipping", nodeName);
                continue;
            }

            // Follow all connections
            node.getConnectedTo().forEach(conn -> queue.add(conn.getTargetNode()));
        }

        return visited.stream().toList();
    }

    private void removeSubgraph(BpmnIntermediateModel model, List<String> nodes) {
        // Simply remove the subgraph nodes.  There can be no connections into or out of the subgraph by definition
        final Set<String> remove = Optional.ofNullable(nodes).map(HashSet::new).orElseGet(HashSet::new);
        model.getNodes().removeIf(n -> remove.contains(n.getName()));
    }

    private Result<BpmnIntermediateModel, String> getModelData() {
        return Optional.ofNullable(getPayload().<String>get(getModelKey()))
                .map(serialized -> Util.tryDeserialize(serialized, BpmnIntermediateModel.class))
                .map(res -> res.mapErr(Exception::toString))
                .orElseGet(() -> Result.Err("No valid input model found"));
    }

    private Result<Void, String> saveModelData(BpmnIntermediateModel model) {
        if (model == null) return Result.Err("Cannot save null model");

        final var serialized = Util.trySerialize(model);
        if (serialized.isErr()) return Result.Err("Cannot serialize model: " + serialized.getError().getMessage());

        getPayload().put(getModelKey(), serialized.getValue());
        return Result.Ok();
    }

    @Override
    public String getDescription() {
        return "Clean up BPMN model for rendering";
    }

}
